"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const atom_1 = require("atom");
const path_1 = require("path");
const Temp = require("temp");
const FS = require("fs");
const CP = require("child_process");
const os_1 = require("os");
const atom_haskell_utils_1 = require("atom-haskell-utils");
exports.getRootDirFallback = atom_haskell_utils_1.getRootDirFallback;
exports.getRootDir = atom_haskell_utils_1.getRootDir;
exports.isDirectory = atom_haskell_utils_1.isDirectory;
let debuglog = [];
const logKeep = 30000;
function savelog(...messages) {
    const ts = Date.now();
    debuglog.push({
        timestamp: ts,
        messages
    });
    debuglog = debuglog.filter(({ timestamp }) => (ts - timestamp) < logKeep);
}
function joinPath(ds) {
    const set = new Set(ds);
    return Array.from(set).join(path_1.delimiter);
}
exports.EOT = `${os_1.EOL}\x04${os_1.EOL}`;
function debug(...messages) {
    if (atom.config.get('haskell-ghc-mod.debug')) {
        console.log('haskell-ghc-mod debug:', ...messages);
    }
    savelog(...messages.map((v) => JSON.stringify(v)));
}
exports.debug = debug;
function warn(...messages) {
    console.warn('haskell-ghc-mod warning:', ...messages);
    savelog(...messages.map((v) => JSON.stringify(v)));
}
exports.warn = warn;
function getDebugLog() {
    const ts = Date.now();
    debuglog = debuglog.filter(({ timestamp }) => (ts - timestamp) < logKeep);
    return debuglog.map(({ timestamp, messages }) => `${(timestamp - ts) / 1000}s: ${messages.join(',')}`).join(os_1.EOL);
}
exports.getDebugLog = getDebugLog;
function execPromise(cmd, args, opts, stdin) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            debug(`Running ${cmd} ${args} with opts = `, opts);
            const child = CP.execFile(cmd, args, opts, (error, stdout, stderr) => {
                if (stderr.trim().length > 0) {
                    warn(stderr);
                }
                if (error) {
                    warn(`Running ${cmd} ${args} failed with `, error);
                    if (stdout) {
                        warn(stdout);
                    }
                    error.stack = (new Error()).stack;
                    return reject(error);
                }
                else {
                    debug(`Got response from ${cmd} ${args}`, { stdout, stderr });
                    return resolve({ stdout, stderr });
                }
            });
            if (stdin) {
                debug(`sending stdin text to ${cmd} ${args}`);
                return child.stdin.write(stdin);
            }
        });
    });
}
exports.execPromise = execPromise;
function getCabalSandbox(rootPath) {
    return __awaiter(this, void 0, void 0, function* () {
        debug('Looking for cabal sandbox...');
        const sbc = yield parseSandboxConfig(`${rootPath}${path_1.sep}cabal.sandbox.config`);
        if (sbc && sbc['install-dirs'] && sbc['install-dirs'].bindir) {
            const sandbox = sbc['install-dirs'].bindir;
            debug('Found cabal sandbox: ', sandbox);
            if (atom_haskell_utils_1.isDirectory(sandbox)) {
                return sandbox;
            }
            else {
                warn('Cabal sandbox ', sandbox, ' is not a directory');
            }
        }
        else {
            warn('No cabal sandbox found');
        }
    });
}
exports.getCabalSandbox = getCabalSandbox;
function getStackSandbox(rootPath, apd, env) {
    return __awaiter(this, void 0, void 0, function* () {
        debug('Looking for stack sandbox...');
        env.PATH = joinPath(apd);
        debug('Running stack with PATH ', env.PATH);
        try {
            const out = yield execPromise('stack', ['path', '--snapshot-install-root', '--local-install-root', '--bin-path'], {
                encoding: 'utf8',
                cwd: rootPath,
                env,
                timeout: atom.config.get('haskell-ghc-mod.initTimeout') * 1000
            });
            const lines = out.stdout.split(os_1.EOL);
            const sir = lines.filter((l) => l.startsWith('snapshot-install-root: '))[0].slice(23) + `${path_1.sep}bin`;
            const lir = lines.filter((l) => l.startsWith('local-install-root: '))[0].slice(20) + `${path_1.sep}bin`;
            const bp = lines.filter((l) => l.startsWith('bin-path: '))[0].slice(10).split(path_1.delimiter).filter((p) => !((p === sir) || (p === lir) || (apd.includes(p))));
            debug('Found stack sandbox ', lir, sir, ...bp);
            return [lir, sir, ...bp];
        }
        catch (err) {
            warn('No stack sandbox found because ', err);
        }
    });
}
exports.getStackSandbox = getStackSandbox;
const processOptionsCache = new Map();
function getProcessOptions(rootPath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!rootPath) {
            rootPath = atom_haskell_utils_1.getRootDirFallback(null).getPath();
        }
        const cached = processOptionsCache.get(rootPath);
        if (cached) {
            return cached;
        }
        debug(`getProcessOptions(${rootPath})`);
        const env = Object.assign({}, process.env);
        if (process.platform === 'win32') {
            const PATH = [];
            const capMask = (str, mask) => {
                const a = str.split('');
                for (let i = 0; i < a.length; i++) {
                    const c = a[i];
                    if (mask & Math.pow(2, i)) {
                        a[i] = a[i].toUpperCase();
                    }
                }
                return a.join('');
            };
            for (let m = 0b1111; m >= 0; m--) {
                const vn = capMask('path', m);
                if (env[vn]) {
                    PATH.push(env[vn]);
                }
            }
            env.PATH = PATH.join(path_1.delimiter);
        }
        const PATH = env.PATH || '';
        const apd = atom.config.get('haskell-ghc-mod.additionalPathDirectories').concat(PATH.split(path_1.delimiter));
        const sbd = false;
        const cabalSandbox = atom.config.get('haskell-ghc-mod.cabalSandbox') ? getCabalSandbox(rootPath) : Promise.resolve();
        const stackSandbox = atom.config.get('haskell-ghc-mod.stackSandbox') ? getStackSandbox(rootPath, apd, Object.assign({}, env)) : Promise.resolve();
        const [cabalSandboxDir, stackSandboxDirs] = yield Promise.all([cabalSandbox, stackSandbox]);
        const newp = [];
        if (cabalSandboxDir) {
            newp.push(cabalSandboxDir);
        }
        if (stackSandboxDirs) {
            newp.push(...stackSandboxDirs);
        }
        newp.push(...apd);
        env.PATH = joinPath(newp);
        debug(`PATH = ${env.PATH}`);
        const res = {
            cwd: rootPath,
            env,
            encoding: 'utf8',
            maxBuffer: Infinity
        };
        processOptionsCache.set(rootPath, res);
        return res;
    });
}
exports.getProcessOptions = getProcessOptions;
function getSymbolAtPoint(editor, point) {
    let range, symbol;
    const inScope = (scope, point2) => editor.scopeDescriptorForBufferPosition(point2).getScopesArray().some((v) => v === scope);
    const tb = editor.getBuffer();
    const line = tb.rangeForRow(point.row);
    const find = (test) => {
        let end = point;
        let start = point;
        let start2 = start.translate([0, -1]);
        while (test(start2) && start2.isGreaterThanOrEqual(line.start)) {
            start = start2;
            start2 = start.translate([0, -1]);
        }
        while (test(end) && end.isLessThan(line.end)) {
            end = end.translate([0, 1]);
        }
        return new atom_1.Range(start, end);
    };
    const regex = /[\w'.]/;
    const scopes = [
        'keyword.operator.haskell',
        'entity.name.function.infix.haskell'
    ];
    for (const scope of scopes) {
        range = find((p) => inScope(scope, p));
        if (!range.isEmpty()) {
            symbol = tb.getTextInRange(range);
            return { scope, range, symbol };
        }
    }
    range = find((p) => tb.getTextInRange([p, p.translate([0, 1])]).match(regex) !== null);
    symbol = tb.getTextInRange(range);
    return { scope: undefined, range, symbol };
}
exports.getSymbolAtPoint = getSymbolAtPoint;
function getSymbolInRange(editor, crange) {
    const buffer = editor.getBuffer();
    if (crange.isEmpty()) {
        return getSymbolAtPoint(editor, crange.start);
    }
    else {
        return {
            symbol: buffer.getTextInRange(crange),
            range: crange
        };
    }
}
exports.getSymbolInRange = getSymbolInRange;
function withTempFile(contents, uri, gen) {
    return __awaiter(this, void 0, void 0, function* () {
        const info = yield new Promise((resolve, reject) => Temp.open({ prefix: 'haskell-ghc-mod', suffix: path_1.extname(uri || '.hs') }, (err, info2) => {
            if (err) {
                reject(err);
            }
            else {
                resolve(info2);
            }
        }));
        return new Promise((resolve, reject) => FS.write(info.fd, contents, (err) => __awaiter(this, void 0, void 0, function* () {
            if (err) {
                reject(err);
            }
            else {
                const res = yield gen(info.path);
                FS.close(info.fd, () => FS.unlink(info.path, () => { }));
                return res;
            }
        })));
    });
}
exports.withTempFile = withTempFile;
function mkError(name, message) {
    const err = new Error(message);
    err.name = name;
    return err;
}
exports.mkError = mkError;
function parseSandboxConfig(file) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const sbc = yield new Promise((resolve, reject) => FS.readFile(file, { encoding: 'utf-8' }, (err, sbc2) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(sbc2);
                }
            }));
            const vars = {};
            let scope = vars;
            const rv = (v) => {
                for (const k1 of Object.keys(scope)) {
                    const v1 = scope[k1];
                    if (typeof v1 === 'string') {
                        v = v.split(`$${k1}`).join(v1);
                    }
                }
                return v;
            };
            for (const line of sbc.split(/\r?\n|\r/)) {
                if (!line.match(/^\s*--/) && !line.match(/^\s*$/)) {
                    const [l] = line.split(/--/);
                    const m = line.match(/^\s*([\w-]+):\s*(.*)\s*$/);
                    if (m) {
                        const [_, name, val] = m;
                        return scope[name] = rv(val);
                    }
                    else {
                        const newscope = {};
                        scope[line] = newscope;
                        return scope = newscope;
                    }
                }
            }
            return vars;
        }
        catch (err) {
            warn('Reading cabal sandbox config failed with ', err);
        }
    });
}
exports.parseSandboxConfig = parseSandboxConfig;
function tabShiftForPoint(buffer, point) {
    const line = buffer.lineForRow(point.row);
    const match = line ? (line.slice(0, point.column).match(/\t/g) || []) : [];
    const columnShift = 7 * match.length;
    return new atom_1.Point(point.row, point.column + columnShift);
}
exports.tabShiftForPoint = tabShiftForPoint;
function tabShiftForRange(buffer, range) {
    const start = tabShiftForPoint(buffer, range.start);
    const end = tabShiftForPoint(buffer, range.end);
    return new atom_1.Range(start, end);
}
exports.tabShiftForRange = tabShiftForRange;
function tabUnshiftForPoint(buffer, point) {
    const line = buffer.lineForRow(point.row);
    let columnl = 0;
    let columnr = point.column;
    while (columnl < columnr) {
        if ((line === undefined) || (line[columnl] === undefined)) {
            break;
        }
        if (line[columnl] === '\t') {
            columnr -= 7;
        }
        columnl += 1;
    }
    return new atom_1.Point(point.row, columnr);
}
exports.tabUnshiftForPoint = tabUnshiftForPoint;
function tabUnshiftForRange(buffer, range) {
    const start = tabUnshiftForPoint(buffer, range.start);
    const end = tabUnshiftForPoint(buffer, range.end);
    return new atom_1.Range(start, end);
}
exports.tabUnshiftForRange = tabUnshiftForRange;
function isUpperCase(ch) {
    return ch.toUpperCase() === ch;
}
exports.isUpperCase = isUpperCase;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFRQSwrQkFBOEM7QUFDOUMsK0JBQThDO0FBQzlDLDZCQUE0QjtBQUM1Qix5QkFBd0I7QUFDeEIsb0NBQW1DO0FBQ25DLDJCQUF3QjtBQUN4QiwyREFBOEU7QUFJdEUsNkJBSkEsdUNBQWtCLENBSUE7QUFBRSxxQkFKQSwrQkFBVSxDQUlBO0FBQUUsc0JBSkEsZ0NBQVcsQ0FJQTtBQUVuRCxJQUFJLFFBQVEsR0FBbUQsRUFBRSxDQUFBO0FBQ2pFLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQTtBQUVyQixpQkFBa0IsR0FBRyxRQUFrQjtJQUNyQyxNQUFNLEVBQUUsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUE7SUFDckIsUUFBUSxDQUFDLElBQUksQ0FBQztRQUNaLFNBQVMsRUFBRSxFQUFFO1FBQ2IsUUFBUTtLQUNULENBQUMsQ0FBQTtJQUNGLFFBQVEsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBQyxTQUFTLEVBQUMsS0FBSyxDQUFDLEVBQUUsR0FBRyxTQUFTLENBQUMsR0FBRyxPQUFPLENBQUMsQ0FBQTtBQUN6RSxDQUFDO0FBRUQsa0JBQW1CLEVBQVk7SUFDN0IsTUFBTSxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUE7SUFDdkIsTUFBTSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLGdCQUFTLENBQUMsQ0FBQTtBQUN4QyxDQUFDO0FBRVksUUFBQSxHQUFHLEdBQUcsR0FBRyxRQUFHLE9BQU8sUUFBRyxFQUFFLENBQUE7QUFFckMsZUFBdUIsR0FBRyxRQUFlO0lBQ3ZDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRTdDLE9B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Q0FBQyxDQUFBO0lBQ3pDLElBQUksT0FBTyxHQUFHLENBQUMsQ0FBQTtJQUNmLElBQUksT0FBTyxHQUFHLEtBQUssQ0FBQyxNQUFNLENBQUE7SUFDMUIsT0FBTyxPQUFPLEdBQUcsT0FBTyxFQUFFLENBQUM7UUFFekIsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQUMsS0FBSyxDQUFBO1FBQUMsQ0FBQztRQUNwRSxFQUFFLENBQUMsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssSUFBSSxDQUFDLENBQUMsQ0FBQztZQUMzQixPQUFPLElBQUksQ0FBQyxDQUFBO1FBQ2QsQ0FBQztRQUNELE9BQU8sSUFBSSxDQUFDLENBQUE7SUFDZCxDQUFDO0lBQ0QsTUFBTSxDQUFDLElBQUksWUFBSyxDQUFDLEtBQUssQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUE7QUFDdEMsQ0FBQztBQWJELGdEQWFDO0FBRUQsNEJBQW9DLE1BQTRCLEVBQUUsS0FBc0I7SUFDdEYsTUFBTSxLQUFLLEdBQUcsa0JBQWtCLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQTtJQUNyRCxNQUFNLEdBQUcsR0FBRyxrQkFBa0IsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFBO0lBQ2pELE1BQU0sQ0FBQyxJQUFJLFlBQUssQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUE7QUFDOUIsQ0FBQztBQUpELGdEQUlDO0FBRUQscUJBQTZCLEVBQVU7SUFDckMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxXQUFXLEVBQUUsS0FBSyxFQUFFLENBQUE7QUFDaEMsQ0FBQztBQUZELGtDQUVDIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIGRlY2FmZmVpbmF0ZSBzdWdnZXN0aW9uczpcbiAqIERTMTAyOiBSZW1vdmUgdW5uZWNlc3NhcnkgY29kZSBjcmVhdGVkIGJlY2F1c2Ugb2YgaW1wbGljaXQgcmV0dXJuc1xuICogRFMyMDE6IFNpbXBsaWZ5IGNvbXBsZXggZGVzdHJ1Y3R1cmUgYXNzaWdubWVudHNcbiAqIERTMjA3OiBDb25zaWRlciBzaG9ydGVyIHZhcmlhdGlvbnMgb2YgbnVsbCBjaGVja3NcbiAqIERTMjA4OiBBdm9pZCB0b3AtbGV2ZWwgdGhpc1xuICogRnVsbCBkb2NzOiBodHRwczovL2dpdGh1Yi5jb20vZGVjYWZmZWluYXRlL2RlY2FmZmVpbmF0ZS9ibG9iL21hc3Rlci9kb2NzL3N1Z2dlc3Rpb25zLm1kXG4gKi9cbmltcG9ydCB7IFJhbmdlLCBQb2ludCwgRGlyZWN0b3J5IH0gZnJvbSAnYXRvbSdcbmltcG9ydCB7IGRlbGltaXRlciwgc2VwLCBleHRuYW1lIH0gZnJvbSAncGF0aCdcbmltcG9ydCAqIGFzIFRlbXAgZnJvbSAndGVtcCdcbmltcG9ydCAqIGFzIEZTIGZyb20gJ2ZzJ1xuaW1wb3J0ICogYXMgQ1AgZnJvbSAnY2hpbGRfcHJvY2VzcydcbmltcG9ydCB7IEVPTCB9IGZyb20gJ29zJ1xuaW1wb3J0IHtnZXRSb290RGlyRmFsbGJhY2ssIGdldFJvb3REaXIsIGlzRGlyZWN0b3J5fSBmcm9tICdhdG9tLWhhc2tlbGwtdXRpbHMnXG5pbXBvcnQgeyBSdW5PcHRpb25zIH0gZnJvbSAnLi9naGMtbW9kL2doYy1tb2RpLXByb2Nlc3MtcmVhbCdcblxudHlwZSBFeGVjT3B0cyA9IENQLkV4ZWNGaWxlT3B0aW9uc1dpdGhTdHJpbmdFbmNvZGluZ1xuZXhwb3J0IHtnZXRSb290RGlyRmFsbGJhY2ssIGdldFJvb3REaXIsIGlzRGlyZWN0b3J5LCBFeGVjT3B0c31cblxubGV0IGRlYnVnbG9nOiBBcnJheTx7dGltZXN0YW1wOiBudW1iZXIsIG1lc3NhZ2VzOiBzdHJpbmdbXX0+ID0gW11cbmNvbnN0IGxvZ0tlZXAgPSAzMDAwMCAvLyBtc1xuXG5mdW5jdGlvbiBzYXZlbG9nICguLi5tZXNzYWdlczogc3RyaW5nW10pIHtcbiAgY29uc3QgdHMgPSBEYXRlLm5vdygpXG4gIGRlYnVnbG9nLnB1c2goe1xuICAgIHRpbWVzdGFtcDogdHMsXG4gICAgbWVzc2FnZXNcbiAgfSlcbiAgZGVidWdsb2cgPSBkZWJ1Z2xvZy5maWx0ZXIoKHt0aW1lc3RhbXB9KSA9PiAodHMgLSB0aW1lc3RhbXApIDwgbG9nS2VlcClcbn1cblxuZnVuY3Rpb24gam9pblBhdGggKGRzOiBzdHJpbmdbXSkge1xuICBjb25zdCBzZXQgPSBuZXcgU2V0KGRzKVxuICByZXR1cm4gQXJyYXkuZnJvbShzZXQpLmpvaW4oZGVsaW1pdGVyKVxufVxuXG5leHBvcnQgY29uc3QgRU9UID0gYCR7RU9MfVxceDA0JHtFT0x9YFxuXG5leHBvcnQgZnVuY3Rpb24gZGVidWcgKC4uLm1lc3NhZ2VzOiBhbnlbXSkge1xuICBpZiAoYXRvbS5jb25maWcuZ2V0KCdoYXNrZWxsLWdoYy1tb2QuZGVidWcnKSkge1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKCdoYXNrZWxsLWdoYy1tb2QgZGVidWc6JywgLi4ubWVzc2FnZXMpXG4gIH1cbiAgc2F2ZWxvZyguLi5tZXNzYWdlcy5tYXAoKHYpID0+IEpTT04uc3RyaW5naWZ5KHYpKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdhcm4gKC4uLm1lc3NhZ2VzOiBhbnlbXSkge1xuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLWNvbnNvbGVcbiAgY29uc29sZS53YXJuKCdoYXNrZWxsLWdoYy1tb2Qgd2FybmluZzonLCAuLi5tZXNzYWdlcylcbiAgc2F2ZWxvZyguLi5tZXNzYWdlcy5tYXAoKHYpID0+IEpTT04uc3RyaW5naWZ5KHYpKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERlYnVnTG9nICgpIHtcbiAgY29uc3QgdHMgPSBEYXRlLm5vdygpXG4gIGRlYnVnbG9nID0gZGVidWdsb2cuZmlsdGVyKCh7dGltZXN0YW1wfSkgPT4gKHRzIC0gdGltZXN0YW1wKSA8IGxvZ0tlZXApXG4gIHJldHVybiBkZWJ1Z2xvZy5tYXAoKHt0aW1lc3RhbXAsIG1lc3NhZ2VzfSkgPT4gYCR7KHRpbWVzdGFtcCAtIHRzKSAvIDEwMDB9czogJHttZXNzYWdlcy5qb2luKCcsJyl9YCkuam9pbihFT0wpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBleGVjUHJvbWlzZSAoY21kOiBzdHJpbmcsIGFyZ3M6IHN0cmluZ1tdLCBvcHRzOiBFeGVjT3B0cywgc3RkaW4/OiBzdHJpbmcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHtzdGRvdXQ6IHN0cmluZywgc3RkZXJyOiBzdHJpbmd9PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgZGVidWcoYFJ1bm5pbmcgJHtjbWR9ICR7YXJnc30gd2l0aCBvcHRzID0gYCwgb3B0cylcbiAgICBjb25zdCBjaGlsZCA9IENQLmV4ZWNGaWxlKGNtZCwgYXJncywgb3B0cywgKGVycm9yLCBzdGRvdXQ6IHN0cmluZywgc3RkZXJyOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmIChzdGRlcnIudHJpbSgpLmxlbmd0aCA+IDApIHsgd2FybihzdGRlcnIpIH1cbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICB3YXJuKGBSdW5uaW5nICR7Y21kfSAke2FyZ3N9IGZhaWxlZCB3aXRoIGAsIGVycm9yKVxuICAgICAgICBpZiAoc3Rkb3V0KSB7IHdhcm4oc3Rkb3V0KSB9XG4gICAgICAgIGVycm9yLnN0YWNrID0gKG5ldyBFcnJvcigpKS5zdGFja1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVidWcoYEdvdCByZXNwb25zZSBmcm9tICR7Y21kfSAke2FyZ3N9YCwge3N0ZG91dCwgc3RkZXJyfSlcbiAgICAgICAgcmV0dXJuIHJlc29sdmUoe3N0ZG91dCwgc3RkZXJyfSlcbiAgICAgIH1cbiAgICB9KVxuICAgIGlmIChzdGRpbikge1xuICAgICAgZGVidWcoYHNlbmRpbmcgc3RkaW4gdGV4dCB0byAke2NtZH0gJHthcmdzfWApXG4gICAgICByZXR1cm4gY2hpbGQuc3RkaW4ud3JpdGUoc3RkaW4pXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FiYWxTYW5kYm94IChyb290UGF0aDogc3RyaW5nKSB7XG4gIGRlYnVnKCdMb29raW5nIGZvciBjYWJhbCBzYW5kYm94Li4uJylcbiAgY29uc3Qgc2JjID0gYXdhaXQgcGFyc2VTYW5kYm94Q29uZmlnKGAke3Jvb3RQYXRofSR7c2VwfWNhYmFsLnNhbmRib3guY29uZmlnYClcbiAgaWYgKHNiYyAmJiBzYmNbJ2luc3RhbGwtZGlycyddICYmIHNiY1snaW5zdGFsbC1kaXJzJ10uYmluZGlyKSB7XG4gICAgY29uc3Qgc2FuZGJveCA9IHNiY1snaW5zdGFsbC1kaXJzJ10uYmluZGlyXG4gICAgZGVidWcoJ0ZvdW5kIGNhYmFsIHNhbmRib3g6ICcsIHNhbmRib3gpXG4gICAgaWYgKGlzRGlyZWN0b3J5KHNhbmRib3gpKSB7XG4gICAgICByZXR1cm4gc2FuZGJveFxuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuKCdDYWJhbCBzYW5kYm94ICcsIHNhbmRib3gsICcgaXMgbm90IGEgZGlyZWN0b3J5JylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2FybignTm8gY2FiYWwgc2FuZGJveCBmb3VuZCcpXG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFN0YWNrU2FuZGJveCAocm9vdFBhdGg6IHN0cmluZyAsIGFwZDogc3RyaW5nW10sIGVudjoge1trZXk6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZH0pIHtcbiAgZGVidWcoJ0xvb2tpbmcgZm9yIHN0YWNrIHNhbmRib3guLi4nKVxuICBlbnYuUEFUSCA9IGpvaW5QYXRoKGFwZClcbiAgZGVidWcoJ1J1bm5pbmcgc3RhY2sgd2l0aCBQQVRIICcsIGVudi5QQVRIKVxuICB0cnkge1xuICAgIGNvbnN0IG91dCA9IGF3YWl0IGV4ZWNQcm9taXNlKCdzdGFjaycsIFsncGF0aCcsICctLXNuYXBzaG90LWluc3RhbGwtcm9vdCcsICctLWxvY2FsLWluc3RhbGwtcm9vdCcsICctLWJpbi1wYXRoJ10sIHtcbiAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICBjd2Q6IHJvb3RQYXRoLFxuICAgICAgZW52LFxuICAgICAgdGltZW91dDogYXRvbS5jb25maWcuZ2V0KCdoYXNrZWxsLWdoYy1tb2QuaW5pdFRpbWVvdXQnKSAqIDEwMDBcbiAgICB9KVxuXG4gICAgY29uc3QgbGluZXMgPSBvdXQuc3Rkb3V0LnNwbGl0KEVPTClcbiAgICBjb25zdCBzaXIgPSBsaW5lcy5maWx0ZXIoKGwpID0+IGwuc3RhcnRzV2l0aCgnc25hcHNob3QtaW5zdGFsbC1yb290OiAnKSlbMF0uc2xpY2UoMjMpICsgYCR7c2VwfWJpbmBcbiAgICBjb25zdCBsaXIgPSBsaW5lcy5maWx0ZXIoKGwpID0+IGwuc3RhcnRzV2l0aCgnbG9jYWwtaW5zdGFsbC1yb290OiAnKSlbMF0uc2xpY2UoMjApICsgYCR7c2VwfWJpbmBcbiAgICBjb25zdCBicCA9XG4gICAgICBsaW5lcy5maWx0ZXIoKGwpID0+XG4gICAgICAgIGwuc3RhcnRzV2l0aCgnYmluLXBhdGg6ICcpKVswXS5zbGljZSgxMCkuc3BsaXQoZGVsaW1pdGVyKS5maWx0ZXIoKHApID0+XG4gICAgICAgICAgISgocCA9PT0gc2lyKSB8fCAocCA9PT0gbGlyKSB8fCAoYXBkLmluY2x1ZGVzKHApKSkpXG4gICAgZGVidWcoJ0ZvdW5kIHN0YWNrIHNhbmRib3ggJywgbGlyLCBzaXIsIC4uLmJwKVxuICAgIHJldHVybiBbbGlyLCBzaXIsIC4uLmJwXVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICB3YXJuKCdObyBzdGFjayBzYW5kYm94IGZvdW5kIGJlY2F1c2UgJywgZXJyKVxuICB9XG59XG5cbmNvbnN0IHByb2Nlc3NPcHRpb25zQ2FjaGUgPSBuZXcgTWFwPHN0cmluZywgUnVuT3B0aW9ucz4oKVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvY2Vzc09wdGlvbnMgKHJvb3RQYXRoPzogc3RyaW5nKTogUHJvbWlzZTxSdW5PcHRpb25zPiB7XG4gIGlmICghIHJvb3RQYXRoKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1udWxsLWtleXdvcmRcbiAgICByb290UGF0aCA9IGdldFJvb3REaXJGYWxsYmFjayhudWxsKS5nZXRQYXRoKClcbiAgfVxuICAvLyBjYWNoZVxuICBjb25zdCBjYWNoZWQgPSBwcm9jZXNzT3B0aW9uc0NhY2hlLmdldChyb290UGF0aClcbiAgaWYgKGNhY2hlZCkge1xuICAgIHJldHVybiBjYWNoZWRcbiAgfVxuXG4gIGRlYnVnKGBnZXRQcm9jZXNzT3B0aW9ucygke3Jvb3RQYXRofSlgKVxuICBjb25zdCBlbnYgPSB7Li4ucHJvY2Vzcy5lbnZ9XG5cbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBjb25zdCBQQVRIID0gW11cbiAgICBjb25zdCBjYXBNYXNrID0gKHN0cjogc3RyaW5nLCBtYXNrOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IGEgPSBzdHIuc3BsaXQoJycpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYyA9IGFbaV1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBuby1iaXR3aXNlXG4gICAgICAgIGlmIChtYXNrICYgTWF0aC5wb3coMiwgaSkpIHtcbiAgICAgICAgICBhW2ldID0gYVtpXS50b1VwcGVyQ2FzZSgpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhLmpvaW4oJycpXG4gICAgfVxuICAgIGZvciAobGV0IG0gPSAwYjExMTE7IG0gPj0gMDsgbS0tKSB7XG4gICAgICBjb25zdCB2biA9IGNhcE1hc2soJ3BhdGgnLCBtKVxuICAgICAgaWYgKGVudlt2bl0pIHtcbiAgICAgICAgUEFUSC5wdXNoKGVudlt2bl0pXG4gICAgICB9XG4gICAgfVxuICAgIGVudi5QQVRIID0gUEFUSC5qb2luKGRlbGltaXRlcilcbiAgfVxuXG4gIGNvbnN0IFBBVEggPSBlbnYuUEFUSCB8fCAnJ1xuXG4gIGNvbnN0IGFwZCA9IGF0b20uY29uZmlnLmdldCgnaGFza2VsbC1naGMtbW9kLmFkZGl0aW9uYWxQYXRoRGlyZWN0b3JpZXMnKS5jb25jYXQoUEFUSC5zcGxpdChkZWxpbWl0ZXIpKVxuICBjb25zdCBzYmQgPSBmYWxzZVxuICBjb25zdCBjYWJhbFNhbmRib3ggPVxuICAgIGF0b20uY29uZmlnLmdldCgnaGFza2VsbC1naGMtbW9kLmNhYmFsU2FuZGJveCcpID8gZ2V0Q2FiYWxTYW5kYm94KHJvb3RQYXRoKSA6IFByb21pc2UucmVzb2x2ZSgpIC8vIHVuZGVmaW5lZFxuICBjb25zdCBzdGFja1NhbmRib3ggPVxuICAgIGF0b20uY29uZmlnLmdldCgnaGFza2VsbC1naGMtbW9kLnN0YWNrU2FuZGJveCcpID8gZ2V0U3RhY2tTYW5kYm94KHJvb3RQYXRoLCBhcGQsIHsuLi5lbnZ9KSA6IFByb21pc2UucmVzb2x2ZSgpXG4gIGNvbnN0IFtjYWJhbFNhbmRib3hEaXIsIHN0YWNrU2FuZGJveERpcnNdID0gYXdhaXQgUHJvbWlzZS5hbGwoW2NhYmFsU2FuZGJveCwgc3RhY2tTYW5kYm94XSlcbiAgY29uc3QgbmV3cCA9IFtdXG4gIGlmIChjYWJhbFNhbmRib3hEaXIpIHtcbiAgICBuZXdwLnB1c2goY2FiYWxTYW5kYm94RGlyKVxuICB9XG4gIGlmIChzdGFja1NhbmRib3hEaXJzKSB7XG4gICAgbmV3cC5wdXNoKC4uLnN0YWNrU2FuZGJveERpcnMpXG4gIH1cbiAgbmV3cC5wdXNoKC4uLmFwZClcbiAgZW52LlBBVEggPSBqb2luUGF0aChuZXdwKVxuICBkZWJ1ZyhgUEFUSCA9ICR7ZW52LlBBVEh9YClcbiAgY29uc3QgcmVzOiBSdW5PcHRpb25zID0ge1xuICAgIGN3ZDogcm9vdFBhdGgsXG4gICAgZW52LFxuICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgbWF4QnVmZmVyOiBJbmZpbml0eVxuICB9XG4gIHByb2Nlc3NPcHRpb25zQ2FjaGUuc2V0KHJvb3RQYXRoLCByZXMpXG4gIHJldHVybiByZXNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN5bWJvbEF0UG9pbnQgKGVkaXRvcjogQXRvbVR5cGVzLlRleHRFZGl0b3IsIHBvaW50OiBBdG9tVHlwZXMuUG9pbnQpIHtcbiAgbGV0IHJhbmdlLCBzeW1ib2xcbiAgY29uc3QgaW5TY29wZSA9IChzY29wZTogc3RyaW5nLCBwb2ludDI6IEF0b21UeXBlcy5JUG9pbnQpID0+XG4gICAgZWRpdG9yLnNjb3BlRGVzY3JpcHRvckZvckJ1ZmZlclBvc2l0aW9uKHBvaW50MikuZ2V0U2NvcGVzQXJyYXkoKS5zb21lKCh2KSA9PiB2ID09PSBzY29wZSlcblxuICBjb25zdCB0YiA9IGVkaXRvci5nZXRCdWZmZXIoKVxuICBjb25zdCBsaW5lID0gdGIucmFuZ2VGb3JSb3cocG9pbnQucm93KVxuICBjb25zdCBmaW5kID0gKHRlc3Q6IChwb2ludDogQXRvbVR5cGVzLlBvaW50KSA9PiBib29sZWFuKSA9PiB7XG4gICAgbGV0IGVuZCA9IHBvaW50XG4gICAgbGV0IHN0YXJ0ID0gcG9pbnRcbiAgICBsZXQgc3RhcnQyID0gc3RhcnQudHJhbnNsYXRlKFswLCAtMV0pXG4gICAgd2hpbGUgKHRlc3Qoc3RhcnQyKSAmJiBzdGFydDIuaXNHcmVhdGVyVGhhbk9yRXF1YWwobGluZS5zdGFydCkpIHtcbiAgICAgIHN0YXJ0ID0gc3RhcnQyXG4gICAgICBzdGFydDIgPSBzdGFydC50cmFuc2xhdGUoWzAsIC0xXSlcbiAgICB9XG4gICAgd2hpbGUgKHRlc3QoZW5kKSAmJiBlbmQuaXNMZXNzVGhhbihsaW5lLmVuZCkpIHtcbiAgICAgIGVuZCA9IGVuZC50cmFuc2xhdGUoWzAsIDFdKVxuICAgIH1cbiAgICByZXR1cm4gbmV3IFJhbmdlKHN0YXJ0LCBlbmQpXG4gIH1cblxuICBjb25zdCByZWdleCA9IC9bXFx3Jy5dL1xuICBjb25zdCBzY29wZXMgPSBbXG4gICAgJ2tleXdvcmQub3BlcmF0b3IuaGFza2VsbCcsXG4gICAgJ2VudGl0eS5uYW1lLmZ1bmN0aW9uLmluZml4Lmhhc2tlbGwnXG4gIF1cbiAgZm9yIChjb25zdCBzY29wZSBvZiBzY29wZXMpIHtcbiAgICByYW5nZSA9IGZpbmQoKHApID0+IGluU2NvcGUoc2NvcGUsIHApKVxuICAgIGlmICghcmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgICBzeW1ib2wgPSB0Yi5nZXRUZXh0SW5SYW5nZShyYW5nZSlcbiAgICAgIHJldHVybiB7c2NvcGUsIHJhbmdlLCBzeW1ib2x9XG4gICAgfVxuICB9XG5cbiAgLy8gZWxzZVxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6IG5vLW51bGwta2V5d29yZFxuICByYW5nZSA9IGZpbmQoKHApID0+IHRiLmdldFRleHRJblJhbmdlKFtwLCBwLnRyYW5zbGF0ZShbMCwgMV0pXSkubWF0Y2gocmVnZXgpICE9PSBudWxsKVxuICBzeW1ib2wgPSB0Yi5nZXRUZXh0SW5SYW5nZShyYW5nZSlcbiAgcmV0dXJuIHtzY29wZTogdW5kZWZpbmVkLCByYW5nZSwgc3ltYm9sfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3ltYm9sSW5SYW5nZSAoZWRpdG9yOiBBdG9tVHlwZXMuVGV4dEVkaXRvciwgY3JhbmdlOiBBdG9tVHlwZXMuUmFuZ2UpIHtcbiAgY29uc3QgYnVmZmVyID0gZWRpdG9yLmdldEJ1ZmZlcigpXG4gIGlmIChjcmFuZ2UuaXNFbXB0eSgpKSB7XG4gICAgcmV0dXJuIGdldFN5bWJvbEF0UG9pbnQoZWRpdG9yLCBjcmFuZ2Uuc3RhcnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN5bWJvbDogYnVmZmVyLmdldFRleHRJblJhbmdlKGNyYW5nZSksXG4gICAgICByYW5nZTogY3JhbmdlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3aXRoVGVtcEZpbGU8VD4gKGNvbnRlbnRzOiBzdHJpbmcsIHVyaTogc3RyaW5nLCBnZW46IChwYXRoOiBzdHJpbmcpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgaW5mbyA9IGF3YWl0IG5ldyBQcm9taXNlPFRlbXAuT3BlbkZpbGU+KFxuICAgIChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgVGVtcC5vcGVuKFxuICAgICAge3ByZWZpeDogJ2hhc2tlbGwtZ2hjLW1vZCcsIHN1ZmZpeDogZXh0bmFtZSh1cmkgfHwgJy5ocycpfSxcbiAgICAgIChlcnIsIGluZm8yKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoaW5mbzIpXG4gICAgICAgIH1cbiAgICB9KSlcbiAgcmV0dXJuIG5ldyBQcm9taXNlPFQ+KChyZXNvbHZlLCByZWplY3QpID0+XG4gICAgRlMud3JpdGUoaW5mby5mZCwgY29udGVudHMsIGFzeW5jIChlcnIpID0+IHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGdlbihpbmZvLnBhdGgpXG4gICAgICAgIEZTLmNsb3NlKGluZm8uZmQsICgpID0+IEZTLnVubGluayhpbmZvLnBhdGgsICgpID0+IHsgLypub29wKi8gfSkpXG4gICAgICAgIHJldHVybiByZXNcbiAgICAgIH1cbiAgICB9KSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1rRXJyb3IgKG5hbWU6IHN0cmluZywgbWVzc2FnZTogc3RyaW5nKSB7XG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKVxuICBlcnIubmFtZSA9IG5hbWVcbiAgcmV0dXJuIGVyclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNhbmRib3hDb25maWdUcmVlIHtbazogc3RyaW5nXTogU2FuZGJveENvbmZpZ1RyZWUgfCBzdHJpbmd9XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBwYXJzZVNhbmRib3hDb25maWcgKGZpbGU6IHN0cmluZykge1xuICB0cnkge1xuICAgIGNvbnN0IHNiYyA9IGF3YWl0IG5ldyBQcm9taXNlPHN0cmluZz4oKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgIEZTLnJlYWRGaWxlKGZpbGUsIHtlbmNvZGluZzogJ3V0Zi04J30sIChlcnIsIHNiYzIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShzYmMyKVxuICAgICAgICB9XG4gICAgICB9KSlcbiAgICBjb25zdCB2YXJzOiBTYW5kYm94Q29uZmlnVHJlZSA9IHt9XG4gICAgbGV0IHNjb3BlID0gdmFyc1xuICAgIGNvbnN0IHJ2ID0gKHY6IHN0cmluZykgPT4ge1xuICAgICAgZm9yIChjb25zdCBrMSBvZiBPYmplY3Qua2V5cyhzY29wZSkpIHtcbiAgICAgICAgY29uc3QgdjEgPSBzY29wZVtrMV1cbiAgICAgICAgaWYgKHR5cGVvZiB2MSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB2ID0gdi5zcGxpdChgJCR7azF9YCkuam9pbih2MSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHZcbiAgICB9XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIHNiYy5zcGxpdCgvXFxyP1xcbnxcXHIvKSkge1xuICAgICAgaWYgKCFsaW5lLm1hdGNoKC9eXFxzKi0tLykgJiYgIWxpbmUubWF0Y2goL15cXHMqJC8pKSB7XG4gICAgICAgIGNvbnN0IFtsXSA9IGxpbmUuc3BsaXQoLy0tLylcbiAgICAgICAgY29uc3QgbSA9IGxpbmUubWF0Y2goL15cXHMqKFtcXHctXSspOlxccyooLiopXFxzKiQvKVxuICAgICAgICBpZiAobSkge1xuICAgICAgICAgIGNvbnN0IFtfLCBuYW1lLCB2YWxdID0gbVxuICAgICAgICAgIHJldHVybiBzY29wZVtuYW1lXSA9IHJ2KHZhbClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBuZXdzY29wZSA9IHt9XG4gICAgICAgICAgc2NvcGVbbGluZV0gPSBuZXdzY29wZVxuICAgICAgICAgIHJldHVybiBzY29wZSA9IG5ld3Njb3BlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhcnNcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgd2FybignUmVhZGluZyBjYWJhbCBzYW5kYm94IGNvbmZpZyBmYWlsZWQgd2l0aCAnLCBlcnIpXG4gIH1cbn1cblxuLy8gQSBkaXJ0eSBoYWNrIHRvIHdvcmsgd2l0aCB0YWJzXG5leHBvcnQgZnVuY3Rpb24gdGFiU2hpZnRGb3JQb2ludCAoYnVmZmVyOiBBdG9tVHlwZXMuVGV4dEJ1ZmZlciwgcG9pbnQ6IEF0b21UeXBlcy5Qb2ludCkge1xuICBjb25zdCBsaW5lID0gYnVmZmVyLmxpbmVGb3JSb3cocG9pbnQucm93KVxuICBjb25zdCBtYXRjaCA9IGxpbmUgPyAobGluZS5zbGljZSgwLCBwb2ludC5jb2x1bW4pLm1hdGNoKC9cXHQvZykgfHwgW10pIDogW11cbiAgY29uc3QgY29sdW1uU2hpZnQgPSA3ICogbWF0Y2gubGVuZ3RoXG4gIHJldHVybiBuZXcgUG9pbnQocG9pbnQucm93LCBwb2ludC5jb2x1bW4gKyBjb2x1bW5TaGlmdClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhYlNoaWZ0Rm9yUmFuZ2UgKGJ1ZmZlcjogQXRvbVR5cGVzLlRleHRCdWZmZXIsIHJhbmdlOiBBdG9tVHlwZXMuUmFuZ2UpIHtcbiAgY29uc3Qgc3RhcnQgPSB0YWJTaGlmdEZvclBvaW50KGJ1ZmZlciwgcmFuZ2Uuc3RhcnQpXG4gIGNvbnN0IGVuZCA9IHRhYlNoaWZ0Rm9yUG9pbnQoYnVmZmVyLCByYW5nZS5lbmQpXG4gIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhYlVuc2hpZnRGb3JQb2ludCAoYnVmZmVyOiBBdG9tVHlwZXMuVGV4dEJ1ZmZlciwgcG9pbnQ6IEF0b21UeXBlcy5Qb2ludCkge1xuICBjb25zdCBsaW5lID0gYnVmZmVyLmxpbmVGb3JSb3cocG9pbnQucm93KVxuICBsZXQgY29sdW1ubCA9IDBcbiAgbGV0IGNvbHVtbnIgPSBwb2ludC5jb2x1bW5cbiAgd2hpbGUgKGNvbHVtbmwgPCBjb2x1bW5yKSB7XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOiBzdHJpY3QtdHlwZS1wcmVkaWNhdGVzXG4gICAgaWYgKChsaW5lID09PSB1bmRlZmluZWQpIHx8IChsaW5lW2NvbHVtbmxdID09PSB1bmRlZmluZWQpKSB7IGJyZWFrIH1cbiAgICBpZiAobGluZVtjb2x1bW5sXSA9PT0gJ1xcdCcpIHtcbiAgICAgIGNvbHVtbnIgLT0gN1xuICAgIH1cbiAgICBjb2x1bW5sICs9IDFcbiAgfVxuICByZXR1cm4gbmV3IFBvaW50KHBvaW50LnJvdywgY29sdW1ucilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhYlVuc2hpZnRGb3JSYW5nZSAoYnVmZmVyOiBBdG9tVHlwZXMuVGV4dEJ1ZmZlciwgcmFuZ2U6IEF0b21UeXBlcy5SYW5nZSkge1xuICBjb25zdCBzdGFydCA9IHRhYlVuc2hpZnRGb3JQb2ludChidWZmZXIsIHJhbmdlLnN0YXJ0KVxuICBjb25zdCBlbmQgPSB0YWJVbnNoaWZ0Rm9yUG9pbnQoYnVmZmVyLCByYW5nZS5lbmQpXG4gIHJldHVybiBuZXcgUmFuZ2Uoc3RhcnQsIGVuZClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzVXBwZXJDYXNlIChjaDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBjaC50b1VwcGVyQ2FzZSgpID09PSBjaFxufVxuIl19